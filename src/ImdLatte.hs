{-# LANGUAGE TemplateHaskell, TypeOperators #-}




module ImdLatte where

import AbsLatte
import qualified Data.Set as Set
import qualified Data.Map as Map

import Control.Category
import Data.Label hiding (get)
import Prelude hiding ((.), id)
import qualified Data.Label as L


import Control.Monad.Identity
import Control.Monad.Except
import Control.Monad.Reader
import Control.Monad.Writer
import Control.Monad.State
import Data.Maybe
import Data.List

-- Haskell module generated by the BNF converter

data Register = Mem Int | RegInt Integer | RegBool Bool | Reg Int
--Reg1 | Reg2 | Reg3 | Reg4 | Reg5
  deriving (Eq, Ord, Show, Read)


data QBlock = QBlock Ident [Quadruple] Int Int
  deriving (Eq, Ord, Show, Read)


type QCode = [Quadruple]

-- niech drugi argument to bedzie zawsze register (nie pamiec)

data Quadruple
    = QAdd Register Register
    | QSub Register Register
    | QMul Register Register
    | QDiv Register Register
    | QMod Register Register
    | QAss Register Register
    | QInc Register
    | QDec Register
    | QRet Register
    | QRetV
    | QLab Ident
    | QJmp Ident

    | QGoToIfEqual Ident Register Register
    | QGoToIfNotEqual Ident Register Register
    | QGoToIfGreater Ident Register Register
    | QGoToIfGreaterEqual Ident Register Register
    | QGoToIfLesser Ident Register Register
    | QGoToIfLesserEqual Ident Register Register


    | QNeg Register
    | QAnd Register Register
    | QOr Register Register
    | QXor Register Register
    | QNot Register
    | QSwap Register Register

    | QCmpIntLt Register Register
    | QCmpIntLe Register Register
    | QCmpIntGt Register Register
    | QCmpIntGe Register Register
    | QCmpIntEq Register Register
    | QCmpIntNe Register Register


    | QAlloc Register Int
    | QConcat Register Register

    | QCall Ident [Register]
    | QLoad Register Register
    | QStore Register Register
    deriving (Eq, Ord, Show, Read)


-- najpierw zaloz, ze nie uzywasz rejestrow ponownie, wszystko zapisuj w zmiennych lokalnych (tu bedzie problem)
-- rozbij na bloki, lista w postaci blok, zmienne lokalne

type BasicBlock = [Quadruple]

data Quad = Quad Op Int Int Int
    deriving (Eq, Ord, Show, Read)
data Op = Add | Mul | Store | Load
    deriving (Eq, Ord, Show, Read)

data Reg = Rax | Rbx | Rcx | Rdx
    deriving (Eq, Ord, Show, Read)


data Location = LocReg Reg | LocVar Int
    deriving (Eq, Ord, Show, Read)


-- preprocessing function, calculates next uses of each quadruple argument
nextUses :: [Quad] -> [Int] -> [(Quad, (Map.Map Int (Maybe Int)))]
nextUses quads aliveBlockEnd = reverse $ nextUsesRev nextUsesMap revQuads where
    revQuads = reverse $ zip [1..] quads
    quadsLen = length quads
    nextUsesMap = Map.fromList (zip aliveBlockEnd (repeat $ quadsLen+1))

nextUsesRev nextUsesMap [] = []
nextUsesRev nextUsesMap ((i, (Quad op x y z)):t1) = (((Quad op x y z), nextUses):t2) where
    rx = Map.lookup x nextUsesMap
    ry = Map.lookup y nextUsesMap
    rz = Map.lookup z nextUsesMap
    nextUses = Map.fromList [(x, rx), (y, ry), (z, rz)]
    m1 = (Map.delete x nextUsesMap)
    m2 = Map.insert y i m1
    newMap = Map.insert z i m2
    t2 = nextUsesRev newMap t1


type Var = Int
type NextUse = Int

data ProgState = ProgState { _addressDesc :: Map.Map Int (Set.Set Location)
                 , _registerDesc :: Map.Map Reg (Set.Set Var)
                 , _spilled :: Map.Map Int Int
                 , _args :: Int
                 , _locals :: Int
                 , _tmps :: Int
                 , _firstFree :: Int
                 , _nextUseInfo :: Map.Map Var NextUse
                 }
                 deriving (Eq, Ord, Show, Read)
mkLabels [''ProgState]

lgets :: MonadState f m => f :-> a -> m a
lgets f = gets (L.get f)

type Eval ev = StateT ProgState (WriterT String (ExceptT String Identity)) ev
runEval mem ev = runIdentity $ runExceptT (runWriterT (evalStateT ev mem))

update :: ProgState :-> a -> a -> Eval ()
update fun val = do
    state <- get
    put $ set fun val state


hasNextUses var nextUsesMap = case Map.lookup var nextUsesMap of
    Nothing -> False
    Just _ -> True

-- does register hold value?
registerHolds :: Reg -> Int -> Eval Bool
registerHolds register value = do
    rdesc <- lgets registerDesc
    case Map.lookup register rdesc of
        Nothing -> return $ False
        Just vars -> case elem value vars of
            True -> return $ True
            False -> return $ False


isRegister :: Location -> Bool
isRegister (LocReg _) = True
isRegister (LocVar _) = False

-- find where the variable is store, prefer register
getLoc :: Int -> Eval Location
getLoc variable = do
    adesc <- lgets addressDesc
    case Map.lookup variable adesc of
        Just held -> return ret where
            regs = Set.toList $ Set.filter isRegister held
            vars = Set.toList $ Set.filter (not . isRegister) held
            ret = head $ regs ++ vars

-- add entry that var is being held in register
addressDescInsert var register = do
    adesc <- lgets addressDesc
    case Map.lookup var adesc of
        Just locations -> update addressDesc (Map.insert var (Set.insert register locations) adesc)
        Nothing -> error "Fatal"

-- replace all entries of var's positions with single register
addressDescReplace var register = do
    adesc <- lgets addressDesc
    update addressDesc (Map.insert var (Set.singleton register) adesc)

-- remove entry that var is being held in register
addressDescDelete var register = do
    adesc <- lgets addressDesc
    case Map.lookup var adesc of
        Just locations -> update addressDesc (Map.insert var (Set.delete register locations) adesc)
        Nothing -> error "Fatal"

-- x is now free, so we'll have to remove it from all addressDesc entries
registerDescRemove :: Reg -> Eval ()
registerDescRemove x = do
    adesc <- lgets addressDesc
    rdesc <- lgets registerDesc
    update registerDesc (Map.insert x Set.empty rdesc)
    update addressDesc $ foldr (Map.alter (removeSingleElement (LocReg x))) adesc (Map.keys adesc)

removeAddressFromAllDesc :: Int -> Eval ()
removeAddressFromAllDesc x = do
    adesc <- lgets addressDesc
    rdesc <- lgets registerDesc
    update addressDesc (Map.insert x Set.empty adesc)
    update registerDesc $ foldr (Map.alter (removeSingleElement x)) rdesc (Map.keys rdesc)

removeSingleElement el (Just set) = Just $ Set.delete el set

registerDescInsert register var = do
    rdesc <- lgets registerDesc
    case Map.lookup register rdesc of
        Just locations -> update registerDesc (Map.insert register (Set.insert var locations) rdesc)
        Nothing -> error "Fatal"


getEmptyRegister = do
    rdesc <- lgets registerDesc
    freeRegs <- return $ Map.keys (Map.filter ((0==) . length) rdesc)
    case (length freeRegs) == 0 of
        True -> spillRegister
        False -> do
            update registerDesc (Map.insert (head freeRegs) Set.empty rdesc)
            return $ head freeRegs


-- it assumes that register holds some vars
-- for a register finds the next line it's used in
nextRegisterUse :: Reg -> Eval Int
nextRegisterUse reg = do
    varUses <- lgets nextUseInfo
    rdesc <- lgets registerDesc
    case Map.lookup reg rdesc of
        Just heldVars -> return firstUseLine where
            filterHeldVars = (flip elem heldVars) . fst
            varUsesList = Map.toList varUses
            firstUseLine = minimum $ map snd (filter filterHeldVars varUsesList)
        Nothing -> error "trying to spill unused register"

-- it assumes that all registers hold some vars (spilling)
-- finds the register which holds variable that is used as last
furthestBusyRegister = do
    rdesc <- lgets registerDesc
    varUses <- lgets nextUseInfo
    regNextUseLines <- mapM nextRegisterUse (Map.keys rdesc)
    let
        furthestLine = maximum regNextUseLines
        regsWithLines = zip (Map.keys rdesc) (regNextUseLines)
        allPairsWithFurthestLine = filter ((furthestLine==) . snd) regsWithLines in
        return $ fst (head allPairsWithFurthestLine)

spillRegister :: Eval Reg
spillRegister = do
    rdesc <- lgets registerDesc
    adesc <- lgets addressDesc
    reg <- furthestBusyRegister
    mapM_ copyToMemory (map fst (filter isDirty (Map.toList adesc)))
    registerDescRemove reg
    return reg

isDirty (var, set) = not $ elem (LocVar var) set

copyToMemory u = do
    new <- lgets firstFree
    spl <- lgets spilled
    update spilled (Map.insert u new spl)
    update firstFree (new+1)
    addressDescInsert u (LocVar u)


-- gives all the registers that hold only one variable y
getExclusiveRegs :: Int -> Eval [Reg]
getExclusiveRegs y = do
    rdesc <- lgets registerDesc
    let
        filterSingleton y set = set == (Set.singleton y)
        filtered = filter ((filterSingleton y) . snd) (Map.toList rdesc) in
        return $ map fst filtered


giveRegister :: Quad -> (Map.Map Int Int) -> Eval Reg
giveRegister (Quad _ x y z) nextUses = do
    adesc <- lgets addressDesc
    rdesc <- lgets registerDesc

    exclusiveRegs <- getExclusiveRegs y
    case (exclusiveRegs /= []) && ((Map.lookup y nextUses) == Nothing) of
        True -> do
            registerDescRemove $ head exclusiveRegs
            return $ head exclusiveRegs
        False -> getEmptyRegister

--sprawdz czy dobrze dziala nastepne uzycie (czy jest rzeczywicsie po komendzie, bo cos czuje, ze nie)


emit :: String -> Eval ()
emit = tell

updateNextUseInfo :: (Map.Map Var NextUse) -> Eval ()
updateNextUseInfo newInfo = do
    oldInfo <- lgets nextUseInfo
    update nextUseInfo (Map.union newInfo oldInfo)

genASM q@(Quad op x y z) nextUses = do
    updateNextUseInfo nextUses
    l <- giveRegister q nextUses
    ypos <- getLoc y
    rholds <- registerHolds l y
    case rholds of
        True -> return ()
        False -> emit $ "Load " ++ (show ypos) ++ (show l)
    zpos <- getLoc z
    emit $ (genInstruction op zpos l)
    addressDescReplace x (LocReg l)
    removeAddressFromAllDesc x
    registerDescInsert l x
    case hasNextUses y nextUses of
        True -> return ()
        False -> removeAddressFromAllDesc y
    case hasNextUses z nextUses of
        True -> return ()
        False -> removeAddressFromAllDesc z

--QuadsIntoAsm :: [Quad] -> String = do
--QuadsIntoAsm quads alive
--    where
--        appendNextUses = nextUses quads alive

    Ok tree -> case runEval (ProgState Map.empty Map.empty 0 0 Void (Void, False) [Reg 1, Reg 2, Reg 3, Reg 4, Reg 5] [] 0 Map.empty) (runProgram tree) of
    runEval (ProgState Map.empty )

--- init values here

data ProgState = ProgState { _addressDesc :: Map.Map Int (Set.Set Location)
                 , _registerDesc :: Map.Map Reg (Set.Set Var)
                 , _spilled :: Map.Map Int Int
                 , _args :: Int
                 , _locals :: Int
                 , _tmps :: Int
                 , _firstFree :: Int
                 , _nextUseInfo :: Map.Map Var NextUse
                 }
                 deriving (Eq, Ord, Show, Read)

genInstruction Store reg memLoc = "mov " ++ (show reg) ++ ", " ++ (show memLoc)
genInstruction Load memLoc reg = "mov " ++ (show memLoc) ++ ", " ++ (show reg)

genInstruction Add memLoc reg = "add" ++ (show memLoc) ++ ", " ++ (show reg)


test2 = nextUses [Quad Add 5 6 7, Quad Mul 1 2 3, Quad Mul 11 1 13] [5, 1, 2]

