{-# LANGUAGE TemplateHaskell, TypeOperators #-}
module ImdLatte where

import AbsLatte
import qualified Data.Set as Set
import qualified Data.Map as Map

import Control.Category
import Data.Label hiding (get)
import Prelude hiding ((.), id)
import qualified Data.Label as L

import System.Exit ( exitFailure, exitSuccess )
import System.IO



import Control.Monad.Identity
import Control.Monad.Except
import Control.Monad.Reader
import Control.Monad.Writer
import Control.Monad.State
import Data.Maybe
import qualified Data.List as List


import QuadData

import Test.QuickCheck
import Test.QuickCheck.Monadic

-- Haskell module generated by the BNF converter

compose x [] = x
compose x (y:ys) = compose (y x) ys

------------------------
----------types and  functions used to operate on the types
-----------------------

type NextUse = Int
type MemoryLocation = Int
type LineNumber = Int
type NextUsesMap = Map.Map Var LineNumber

data QuadProgState = QuadProgState { _addressDesc :: Map.Map Int (Set.Set Reg, Set.Set Var) -- replace this set with two sets/lists
                 , _registerDesc :: Map.Map Reg (Set.Set Var)
                 , _firstFree :: Int
                 , _nextUseInfo :: Map.Map Var NextUse
                 , _varLocations :: Map.Map Var MemoryLocation
                 }
                 deriving (Eq, Ord, Show, Read)
mkLabels [''QuadProgState]

lgets :: MonadState f m => f :-> a -> m a
lgets f = gets (L.get f)

type Eval ev = StateT QuadProgState (WriterT [ASM] (ExceptT String Identity)) ev
runEval mem ev = runIdentity $ runExceptT (runWriterT (runStateT ev mem))

update :: QuadProgState :-> a -> a -> Eval ()
update fun val = do
    state <- get
    put $ set fun val state


emit :: ASM -> Eval ()
emit asm = tell [asm]


alterAll f m = result where
    keys = Map.keys m
    result = foldl (flip (Map.alter f)) m keys

--- this remove vals from all set values (and also the key if the set turns out empty)
removeFromAllSets val m = result where
    deleteElement (Just s) = case Set.null $ Set.delete val s of
        True -> Nothing
        False -> Just $ Set.delete val s
    deleteElement Nothing = Nothing
    result = alterAll deleteElement m

replaceVarWithReg v1 v2 m = result where
    replaceElement (Just (regs, vars)) = case elem v1 vars of
        True -> Just $ (Set.insert v2 regs, Set.delete v1 vars)
        False -> Just (regs, vars)
    replaceElement Nothing = Nothing
    result = alterAll replaceElement m

removeRegFromDescs reg m = result where
    removeReg Nothing = Nothing
    removeReg (Just (regs, vars)) = Just (Set.delete reg regs, vars)
    result = alterAll removeReg m

---------------------------------------------------
----- functions calculating next uses of quadruples
-------------------------------------------------------

-- Updates map of next uses to its state from before quadruple
nextUsesBeforeQuad :: NextUsesMap -> LineNumber -> Quad -> NextUsesMap
nextUsesBeforeQuad nextUses lineNum q = result where
    insertList (h:t) m = insertList t (Map.insert h lineNum m)
    insertList [] m = m
    deleteList (h:t) m = deleteList t (Map.delete h m)
    deleteList [] m = m
    used = usedInQuad q
    defined = definedInQuad q

    result = insertList used (deleteList defined nextUses)


definedInQuad :: Quad -> [Var]
definedInQuad (Quad4 x _ y z) = [x]
definedInQuad (QuadNoAssign _ y z) = []

yAndZ :: Quad -> (QArgument, QArgument)
yAndZ (Quad4 _ _ y z) = (y, z)
yAndZ (QuadNoAssign _ y z) = (y, z)

usedInQuad q = result where
    (y, z) = yAndZ q
    filterVar (QaVar x) = [x]
    filterVar _ = []
    usedInName name = case name of
        QaVar var -> [var]
        QaList l -> concat (map filterVar l)
        _ -> []
    result = List.nub $ (usedInName y) ++ (usedInName z)



--- helper function, takes reveresd list with line numbers and returns for each quadruple information about next uses of
--- its variables
revNextUsesList :: [(LineNumber, Quad)] -> NextUsesMap -> [NextUsesMap]
revNextUsesList [] nextUses = [nextUses]
revNextUsesList ((lineNum, q):t) nextUses = result where
    nextUsesBefore = nextUsesBeforeQuad nextUses lineNum q
    allNames = List.nub $ (definedInQuad q) ++ (usedInQuad q)
    filterFun k val = elem k allNames
    result = (Map.filterWithKey filterFun nextUses):(revNextUsesList t nextUsesBefore)


-- appends next uses to each line and returns variable alive at the beginning of the block
-- IMPORTANT function
appendNextUses :: [Quad] -> [Var] -> ([(Quad, NextUsesMap)], [Var])
appendNextUses quads aliveBlockEnd = result where
    numberedReversed = reverse $ zip [1..] quads
    countQuads = length quads
    nextUsesAtTheEnd = Map.fromList $ zip aliveBlockEnd (repeat (countQuads + 1))
    revNextResult = reverse $ revNextUsesList numberedReversed nextUsesAtTheEnd
    aliveStart = Map.keys $ head revNextResult
    quadsWithUses = zip quads (tail revNextResult)
    result = (quadsWithUses, aliveStart)
-------------------------------------
--------------------------------------------------
--------------------------------------------------
----------------------------------------









-- it assumes that register holds some vars
-- for a register finds the next line it's used in
nextRegisterUse :: Reg -> Eval Int
nextRegisterUse reg = do
    varUses <- lgets nextUseInfo
    rdesc <- lgets registerDesc
    case Map.lookup reg rdesc of
        Just heldVars -> return firstUseLine where
            filterHeldVars = (flip elem heldVars) . fst
            varUsesList = Map.toList varUses
            firstUseLine = minimum $ map snd (filter filterHeldVars varUsesList)
        Nothing -> error "trying to spill unused register"

-- it assumes that all registers hold some vars (spilling)
-- finds the register which holds variable that is used as last
-- TODO test it
furthestBusyRegister = do
    rdesc <- lgets registerDesc
    varUses <- lgets nextUseInfo
    regNextUseLines <- mapM nextRegisterUse (Map.keys rdesc)
    let
        furthestLine = maximum regNextUseLines
        regsWithLines = zip (Map.keys rdesc) (regNextUseLines)
        allPairsWithFurthestLine = filter ((furthestLine==) . snd) regsWithLines in
        return $ fst (head allPairsWithFurthestLine)




-----------------------------------
whereInMemory :: Var -> Eval AmdArg
whereInMemory var = do
    varLocs <- lgets varLocations
    case Map.lookup var varLocs of
        Just loc -> return $ AAMem loc
        Nothing -> do
            fl <- lgets firstFree
            update firstFree (fl+1)
            return $ AAMem fl


varDirty :: Var -> Eval Bool
varDirty var = do
    adesc <- lgets addressDesc
    case Map.lookup var adesc of
        Just (regs, vars) -> return $ not (Set.member var vars)
        Nothing -> error "wrong var"


--helper, assumes that var is in reg. It makes sure that var is in it's position in memory. reg will hold everything that
-- was in ver's memory positon
saveVarToMemory :: Reg -> Var -> Eval ()
saveVarToMemory reg var = do
    adesc <- lgets addressDesc
    rdesc <- lgets registerDesc
    whereMem <- whereInMemory var
    emit $ APush whereMem
    emit $ AMov (AAReg reg) whereMem
    emit $ APop (AAReg reg)

    update addressDesc (replaceVarWithReg var reg adesc)

    let
        filterFun k (regs, vars) = (Set.member var vars)
        varsHeldByReg = Set.fromList $ Map.keys (Map.filterWithKey filterFun adesc) in
        update registerDesc (Map.insert reg varsHeldByReg rdesc)


spillReg :: Reg -> Eval ()
spillReg reg = do
    rdesc <- lgets registerDesc
    case Map.lookup reg rdesc of
        Just heldVars -> do
            varsToSave <- filterM varDirty (Set.toList heldVars)
            case varsToSave of
                (h:t) -> do
                    saveVarToMemory reg h
                    spillReg reg
                [] -> return ()
        Nothing -> return ()

-- TODO
--saveVarsToMemory :: [Var] -> Eval ()
--saveVarsToMemory vars = do where
--    varsToSave <- filterM varDirty (vars)














---------------------------------------------------
---------------------------------------------------------------
------------------find register that holds only vars if there is such-----------------
findExclusiveRegister :: Var -> Eval (Maybe Reg)
findExclusiveRegister var = do
    rdesc <- lgets registerDesc
    let
        filterFun key val = (elem key (Map.keys rdesc)) && (val == (Set.singleton var))
        registersHoldingOnlyVar = Map.keys $ Map.filterWithKey filterFun rdesc in
        case registersHoldingOnlyVar of
            (reg:_) -> return $ Just reg
            [] -> return Nothing






-- If y is in register that holds only one variable and y has no next uses, give the register holding y
--- if failed, find next free register
-- if failed spill
giveReg :: QArgument -> Eval (Reg)
giveReg (QaVar y) = do
    nextUses <- lgets nextUseInfo
    adesc <- lgets addressDesc
    rdesc <- lgets registerDesc

    exclusiveReg <- findExclusiveRegister y
    case (exclusiveReg, Map.lookup y nextUses) of
        (Just reg, Nothing) -> do
            update addressDesc (removeRegFromDescs reg adesc) -- register still holds value, not sure if it's ok
            return reg
        _ -> case allRegisters List.\\ (Map.keys rdesc) of -- check if there are any free registers
            (reg:_) -> return reg
            [] -> do
                reg <- furthestBusyRegister
                spillReg reg
                return reg

giveReg (QaConst y) = do
    rdesc <- lgets registerDesc
    case allRegisters List.\\ (Map.keys rdesc) of -- check if there are any free registers
        (reg:_) -> return reg
        [] -> do
            reg <- furthestBusyRegister --TODO perhaps fix it, beacause the implemention is old
            spillReg reg
            return reg

giveReg _ = error "giveReg used in wrong place"


isRegister :: AmdArg -> Bool
isRegister (AAReg _) = True
isRegister (AAMem _) = False
isRegister (AAConst _) = False

whereVarPreferReg :: QArgument -> Eval AmdArg
whereVarPreferReg (QaVar var) = do
    rdesc <- lgets registerDesc
    adesc <- lgets addressDesc
    case Map.lookup var adesc of
        Just (regs, vars) -> case Set.null regs of
            True -> whereInMemory (head $ Set.toList vars)
            False -> return $ AAReg (head (Set.toList regs))
        Nothing -> error "var is nowhere"

whereVarPreferReg (QaConst c) = return $ AAConst c


updateNextUses :: (Map.Map Var NextUse) -> Eval ()
updateNextUses newInfo = do
    oldInfo <- lgets nextUseInfo
    update nextUseInfo (Map.union newInfo oldInfo)


forgetIfUnused :: Var -> Eval ()
forgetIfUnused var = do
    rdesc <- lgets registerDesc
    adesc <- lgets addressDesc
    nextUses <- lgets nextUseInfo

    case Map.lookup var nextUses of
        Just line -> return ()
        Nothing -> do
            update addressDesc (Map.delete var adesc)
            update registerDesc (removeFromAllSets var rdesc)


--special ones: fun, jump, assign,
--x is var, y may be QaConst Int QaVar Int

quadToAsm (QuadNoAssign OpRetV QaEmpty QaEmpty) nu = error "TODO"
quadToAsm (QuadNoAssign OpRet arg QaEmpty) nu = error "TODO"
quadToAsm (QuadNoAssign (OpAllocString pos len) QaEmpty QaEmpty) nu = error "TODO"
quadToAsm (QuadNoAssign (OpJmp label) QaEmpty QaEmpty) nu = error "TODO"
quadToAsm (QuadNoAssign (OpGoToIfFalse label) arg1 QaEmpty) nu = error "TODO"
quadToAsm (QuadNoAssign (OpLabel label) QaEmpty QaEmpty) nu = error "TODO"
quadToAsm (QuadNoAssign (OpCall fname) args QaEmpty) nu = error "TODO"

quadToAsm q@(Quad4 x op y z) nextUses = do
    rdesc <- lgets registerDesc
    adesc <- lgets addressDesc
    updateNextUses nextUses
    case Map.lookup x nextUses of
        Just xline -> do
            l <- giveReg y
            case y of
                QaVar vy -> case (Just $ Set.singleton vy) /= (Map.lookup l rdesc) of
                    True -> emit $ AMov (AAMem vy) (AAReg l)
                    False -> return ()
                QaConst cy -> return ()
            case z of
                QaEmpty -> case op of
                    OpAssVar -> return ()
                _ -> do
                    zp <- whereVarPreferReg z
                    case (zp, op) of
                        (zarg, OpAdd) -> emit $ AAdd zarg (AAReg l)
                        (zarg, OpSub) -> emit $ ASub zarg (AAReg l)
                        (zarg, OpMul) -> emit $ AMul zarg (AAReg l)
                        (zarg, OpDiv) -> do
                            emit $ AMov (AAReg l) (AAReg Rax)
                            emit $ ACdq
                            emit $ ADiv zarg
                            emit $ AMov (AAReg Rax) (AAReg l)
                        (zarg, OpMod) -> do
                            emit $ AMov (AAReg l) (AAReg Rax)
                            emit $ ACdq
                            emit $ ADiv zarg
                            emit $ AMov (AAReg Rdx) (AAReg l)
                        (zarg, OpNeg) -> emit $ ANeg (AAReg l)
                        (zarg, OpAnd) -> emit $ AAnd zarg (AAReg l)
                        (zarg, OpOr) -> emit $ AOr zarg (AAReg l)
                        (zarg, OpCmpIntLt) -> emit $ AOr zarg (AAReg l)


            update addressDesc (Map.insert x (Set.singleton l, Set.empty) adesc)
            update registerDesc (compose rdesc [removeFromAllSets x, Map.insert l (Set.singleton x)])
            case y of
                QaVar vy -> forgetIfUnused vy
                QaConst cy-> return ()
            case z of
                QaVar vz -> forgetIfUnused vz
                _ -> return ()
        Nothing -> return ()

-- We assume that all t
-- TODO 1 musi zwrocic liczbe spilled, zeby zaalokowac i zwolnic dodatkowa pamiec
-- Nie bedziemy zwalniac, te dodatkowo zaalokowane wartosci moga rosnac jak jest duzo blokow
-- (no ale nie bedzie duzo blokow ofc)
quadsToAsm wrappedNextUses = do
    mapM_ (uncurry quadToAsm) wrappedNextUses


-- all living variables mu be in the memory at the end

--Map.filterWithKey () where
--    adesc <- lgets addressDesc
--    filterDirty k v = (elem k aliveVars) && (not $ k elem v)
--    varsToSave = Map.filterWithKey filterDirty adesc



-- trzebaj eszcze zapisac do pamieci ofc
--required: aliveBlockEnd, args, locals, tmps, quads
--- firstFree is in memory
runQuadsToAsm quads aliveBlockEnd addressDesc firstFree varLocs =
    let
        initAddressDesc = addressDesc
        initRegisterDesc = Map.empty
        initFirstFree = firstFree
        initNextUseInfo = Map.empty
        initVarLocations = varLocs
        (wrapNextUses, aliveStart) = appendNextUses quads aliveBlockEnd
        pState = QuadProgState initAddressDesc initRegisterDesc initFirstFree initNextUseInfo initVarLocations
        evalResult = runEval pState (quadsToAsm wrapNextUses) in
        case evalResult of
            Right ((a, s), w) -> return $ w
            Left errMessage -> do hPutStrLn stderr errMessage
                                  exitFailure

-- initAddressDesc = Map.fromList $ zip [1..firstFree-1] (map (Set.singleton . AAMem) [1..firstFree-1])
--test2 = nextUses [Quad Add 5 6 7, Quad Mul 1 2 3, Quad Mul 11 1 13] [5, 1, 2]

quad1 = Quad4 1 OpAdd (QaVar 2) (QaVar 3)
quad2 = Quad4 4 OpAdd (QaVar 5) (QaVar 6)
quad3 = Quad4 7 OpAdd (QaVar 8) (QaVar 9)
quad4 = Quad4 10 OpAdd (QaVar 11) (QaVar 12)
quad5 = Quad4 13 OpAdd (QaVar 14) (QaVar 15)
quads :: [Quad]
quads = [quad1, quad2, quad3, quad4, quad5]
--prepareQuads quads = reverse (zip [1..] quads)
--alQuad :: Map.Map Var LineNumber
--alQuad = Map.fromList [(1, 100), (5, 100)]


--ret = runQuadsToAsm quads 200 [1, 4, 7, 10, 13]


--- TODO --------------pozapisuj zmienne, potem duzo testow
----------------------
------testing functions
------------jhhhhhhh--




-----------------------
-----Test giveReg----
------------------
---------TESTING HERE
testGiveReg1 = let
        --- here starting conditions
        prepAdesc x = (Set.empty, Set.singleton x)
        ad = Map.fromList $ zip [1..5] (map prepAdesc [1..5])
        rd = Map.empty
        ff = 20
        nui = Map.empty
        vl = Map.fromList $ zip [1..5] [1..5]
        pState = QuadProgState ad rd ff nui vl
        evalResult = runEval pState (giveReg (QaVar 4)) in
        case evalResult of
            Right ((a, s), w) -> do
                runTest (ff == 21) "testGiveReg1"
                runTest (Map.null nui) "sdf"
            Left errMessage -> do hPutStrLn stderr "Testing failed badly"
                                  hPutStrLn stderr errMessage
                                  exitFailure


runTest :: Bool -> String -> IO ()
runTest ok msg = do
    case ok of
        True -> putStrLn "OK"
        False -> do hPutStrLn stderr "tests failed"
                    hPutStrLn stderr msg
                    exitFailure
------------------------------------
-----------------------------------

---- w prelude musi byc alokacja statyczna!
-------------------------------





















