{-# LANGUAGE TemplateHaskell, TypeOperators #-}
module ImdLatte where

import AbsLatte
import qualified Data.Set as Set
import qualified Data.Map as Map

import Control.Category
import Data.Label hiding (get)
import Prelude hiding ((.), id)
import qualified Data.Label as L

import System.Exit ( exitFailure, exitSuccess )
import System.IO



import Control.Monad.Identity
import Control.Monad.Except
import Control.Monad.Reader
import Control.Monad.Writer
import Control.Monad.State
import Data.Maybe
import qualified Data.List as List
import ASM


import QuadData

import Test.QuickCheck
import Test.QuickCheck.Monadic

-- Haskell module generated by the BNF converter

compose x [] = x
compose x (y:ys) = compose (y x) ys

------------------------
----------types and  functions used to operate on the types
-----------------------

type NextUse = Int
type MemoryLocation = Int
type LineNumber = Int
type NextUsesMap = Map.Map Var LineNumber

data QuadProgState = QuadProgState { _addressDesc :: AddressDescriptions -- replace this set with two sets/lists
                 , _registerDesc :: Map.Map Reg (Set.Set Var)
                 , _firstFree :: Int
                 , _nextUseInfo :: Map.Map Var NextUse
                 , _varLocations :: Map.Map Var MemoryLocation
                 }
                 deriving (Eq, Ord, Show, Read)
mkLabels [''QuadProgState]

lgets :: MonadState f m => f :-> a -> m a
lgets f = gets (L.get f)

type Eval ev = StateT QuadProgState (WriterT [ASM] (ExceptT String Identity)) ev
runEval mem ev = runIdentity $ runExceptT (runWriterT (runStateT ev mem))

update :: QuadProgState :-> a -> a -> Eval ()
update fun val = do
    state <- get
    put $ set fun val state


emit :: ASM -> Eval ()
emit asm = tell [asm]


alterAll f m = result where
    keys = Map.keys m
    result = foldl (flip (Map.alter f)) m keys

--- this remove vals from all set values (and also the key if the set turns out empty)
removeFromAllSets val m = result where
    deleteElement (Just s) = case Set.null $ Set.delete val s of
        True -> Nothing
        False -> Just $ Set.delete val s
    deleteElement Nothing = Nothing
    result = alterAll deleteElement m

replaceVarWithReg v1 v2 m = result where
    replaceElement (Just (regs, vars)) = case elem v1 vars of
        True -> Just $ (Set.insert v2 regs, Set.delete v1 vars)
        False -> Just (regs, vars)
    replaceElement Nothing = Nothing
    result = alterAll replaceElement m

removeRegFromDescs reg m = result where
    removeReg Nothing = Nothing
    removeReg (Just (regs, vars)) = Just (Set.delete reg regs, vars)
    result = alterAll removeReg m

---------------------------------------------------
----- functions calculating next uses of quadruples
-------------------------------------------------------

-- Updates map of next uses to its state from before quadruple
nextUsesBeforeQuad :: NextUsesMap -> LineNumber -> Quad -> NextUsesMap
nextUsesBeforeQuad nextUses lineNum q = result where
    insertList (h:t) m = insertList t (Map.insert h lineNum m)
    insertList [] m = m
    deleteList (h:t) m = deleteList t (Map.delete h m)
    deleteList [] m = m
    used = usedInQuad q
    defined = definedInQuad q

    result = insertList used (deleteList defined nextUses)


definedInQuad :: Quad -> [Var]
definedInQuad (Quad4 x _ y z) = [x]
definedInQuad (QuadNoAssign _ y z) = []

definedInBlock :: [Quad] -> [Var]
definedInBlock quads = List.nub $ concatMap definedInQuad quads

yAndZ :: Quad -> (QArgument, QArgument)
yAndZ (Quad4 _ _ y z) = (y, z)
yAndZ (QuadNoAssign _ y z) = (y, z)

usedInQuad q = result where
    (y, z) = yAndZ q
    filterVar (QaVar x) = [x]
    filterVar _ = []
    usedInName name = case name of
        QaVar var -> [var]
        QaList l -> concat (map filterVar l)
        _ -> []
    result = List.nub $ (usedInName y) ++ (usedInName z)

usedInBlock quads = List.nub $ concatMap usedInQuad quads


--- helper function, takes reveresd list with line numbers and returns for each quadruple information about next uses of
--- its variables
revNextUsesList :: [(LineNumber, Quad)] -> NextUsesMap -> [NextUsesMap]
revNextUsesList [] nextUses = [nextUses]
revNextUsesList ((lineNum, q):t) nextUses = result where
    nextUsesBefore = nextUsesBeforeQuad nextUses lineNum q
    allNames = List.nub $ (definedInQuad q) ++ (usedInQuad q)
    filterFun k val = elem k allNames
    result = (Map.filterWithKey filterFun nextUses):(revNextUsesList t nextUsesBefore)


-- appends next uses to each line and returns variable alive at the beginning of the block
-- IMPORTANT function
appendNextUses :: [Quad] -> [Var] -> ([(Quad, NextUsesMap)], [Var])
appendNextUses quads aliveBlockEnd = result where
    numberedReversed = reverse $ zip [1..] quads
    countQuads = length quads
    nextUsesAtTheEnd = Map.fromList $ zip aliveBlockEnd (repeat (countQuads + 1))
    revNextResult = reverse $ revNextUsesList numberedReversed nextUsesAtTheEnd
    aliveStart = Map.keys $ head revNextResult
    quadsWithUses = zip quads (tail revNextResult)
    result = (quadsWithUses, aliveStart)
-------------------------------------
--------------------------------------------------
--------------------------------------------------
----------------------------------------









-- it assumes that register holds some vars
-- for a register finds the next line it's used in
nextRegisterUse :: Reg -> Eval Int
nextRegisterUse reg = do
    varUses <- lgets nextUseInfo
    rdesc <- lgets registerDesc
    case Map.lookup reg rdesc of
        Just heldVars -> return firstUseLine where
            filterHeldVars = (flip elem heldVars) . fst
            varUsesList = Map.toList varUses
            firstUseLine = minimum $ map snd (filter filterHeldVars varUsesList)
        Nothing -> error "trying to spill unused register"

-- it assumes that all registers hold some vars (spilling)
-- finds the register which holds variable that is used as last
-- TODO test it
furthestBusyRegister = do
    rdesc <- lgets registerDesc
    varUses <- lgets nextUseInfo
    regNextUseLines <- mapM nextRegisterUse (Map.keys rdesc)
    let
        furthestLine = maximum regNextUseLines
        regsWithLines = zip (Map.keys rdesc) (regNextUseLines)
        allPairsWithFurthestLine = filter ((furthestLine==) . snd) regsWithLines in
        return $ fst (head allPairsWithFurthestLine)




-----------------------------------
whereInMemory :: Var -> Eval AmdArg
whereInMemory var = do
    varLocs <- lgets varLocations
    case Map.lookup var varLocs of
        Just loc -> return $ AAMem loc
        Nothing -> do
            fl <- lgets firstFree
            update firstFree (fl+1)
            return $ AAMem fl


varDirty :: Var -> Eval Bool
varDirty var = do
    adesc <- lgets addressDesc
    case Map.lookup var adesc of
        Just (regs, vars) -> return $ not (Set.member var vars)
        Nothing -> error "wrong var"


--helper, assumes that var is in reg. It makes sure that var is in it's position in memory. reg will hold everything that
-- was in ver's memory positon
saveVarToMemory :: Reg -> Var -> Eval ()
saveVarToMemory reg var = do
    adesc <- lgets addressDesc
    rdesc <- lgets registerDesc
    whereMem <- whereInMemory var
    emit $ APush whereMem
    emit $ AMov (AAReg reg) whereMem
    emit $ APop (AAReg reg)

    update addressDesc (replaceVarWithReg var reg adesc)

    let
        filterFun k (regs, vars) = (Set.member var vars)
        varsHeldByReg = Set.fromList $ Map.keys (Map.filterWithKey filterFun adesc) in
        update registerDesc (Map.insert reg varsHeldByReg rdesc)


spillReg :: Reg -> Eval ()
spillReg reg = do
    rdesc <- lgets registerDesc
    case Map.lookup reg rdesc of
        Just heldVars -> do
            varsToSave <- filterM varDirty (Set.toList heldVars)
            case varsToSave of
                (h:t) -> do
                    saveVarToMemory reg h
                    spillReg reg
                [] -> return ()
        Nothing -> return ()

saveVarsAfterBlock :: [Var] -> Eval ()
saveVarsAfterBlock vars = do
    adesc <- lgets addressDesc
    rdesc <- lgets registerDesc
    dirtyVars <- filterM varDirty vars

    -- TODO can be improved
    whereNow <- mapM (whereVarPreferReg . QaVar) dirtyVars
    whereShould <- mapM whereInMemory dirtyVars

    mapM_ (emit . APush) whereNow
    mapM_ (emit . APop) (reverse whereShould)

    let
        sets = zip (repeat Set.empty) (map Set.singleton vars)
        newMap = Map.fromList $ zip vars sets in
        update addressDesc newMap


















---------------------------------------------------
---------------------------------------------------------------
------------------find register that holds only vars if there is such-----------------
findExclusiveRegister :: Var -> Eval (Maybe Reg)
findExclusiveRegister var = do
    rdesc <- lgets registerDesc
    let
        filterFun key val = (elem key (Map.keys rdesc)) && (val == (Set.singleton var))
        registersHoldingOnlyVar = Map.keys $ Map.filterWithKey filterFun rdesc in
        case registersHoldingOnlyVar of
            (reg:_) -> return $ Just reg
            [] -> return Nothing






-- If y is in register that holds only one variable and y has no next uses, give the register holding y
--- if failed, find next free register
-- if failed spill
giveReg :: QArgument -> Eval (Reg)
giveReg (QaVar y) = do
    nextUses <- lgets nextUseInfo
    adesc <- lgets addressDesc
    rdesc <- lgets registerDesc

    exclusiveReg <- findExclusiveRegister y
    case (exclusiveReg, Map.lookup y nextUses) of
        (Just reg, Nothing) -> do
            update addressDesc (removeRegFromDescs reg adesc) -- register still holds value, not sure if it's ok
            return reg
        _ -> case workingRegisters List.\\ (Map.keys rdesc) of -- check if there are any free registers
            (reg:_) -> return reg
            [] -> do
                reg <- furthestBusyRegister
                spillReg reg
                return reg

giveReg (QaConst y) = do
    rdesc <- lgets registerDesc
    case workingRegisters List.\\ (Map.keys rdesc) of -- check if there are any free registers
        (reg:_) -> return reg
        [] -> do
            reg <- furthestBusyRegister --TODO perhaps fix it, beacause the implemention is old
            spillReg reg
            return reg

giveReg _ = error "giveReg used in wrong place"


isRegister :: AmdArg -> Bool
isRegister (AAReg _) = True
isRegister (AAMem _) = False
isRegister (AAConst _) = False

whereVarPreferReg :: QArgument -> Eval AmdArg
whereVarPreferReg (QaVar var) = do
    rdesc <- lgets registerDesc
    adesc <- lgets addressDesc
    case Map.lookup var adesc of
        Just (regs, vars) -> case Set.null regs of
            True -> whereInMemory (head $ Set.toList vars)
            False -> return $ AAReg (head (Set.toList regs))
        Nothing -> error "var is nowhere"

whereVarPreferReg (QaConst c) = return $ AAConst c


updateNextUses :: (Map.Map Var NextUse) -> Eval ()
updateNextUses newInfo = do
    oldInfo <- lgets nextUseInfo
    update nextUseInfo (Map.union newInfo oldInfo)


forgetIfUnused :: Var -> Eval ()
forgetIfUnused var = do
    rdesc <- lgets registerDesc
    adesc <- lgets addressDesc
    nextUses <- lgets nextUseInfo

    case Map.lookup var nextUses of
        Just line -> return ()
        Nothing -> do
            update addressDesc (Map.delete var adesc)
            update registerDesc (removeFromAllSets var rdesc)










---
--- Translating single quadruple to assembly
---
quadToAsm (QuadNoAssign OpRet QaEmpty QaEmpty) nu =  emit ARet
quadToAsm (QuadNoAssign OpRet arg QaEmpty) nu = do
    case arg of
        QaVar v -> do
            vl <- lgets varLocations
            case Map.lookup v vl of
                Just mem -> do
                    emit $ AMov (AAMem mem) (AAReg Rax)
                    emit ARet
                Nothing -> error "variable not declared"
        QaConst c -> do
            emit $ AMov (AAConst c) (AAReg Rax)
            emit ARet

quadToAsm (QuadNoAssign (OpJmp label) QaEmpty QaEmpty) nu = emit $ AJmp label
quadToAsm (QuadNoAssign (OpLabel label) QaEmpty QaEmpty) nu = emit $ ALab label
quadToAsm (QuadNoAssign (OpGoToIfFalse label) arg1 QaEmpty) nu = error "TODO"
quadToAsm (Quad4 x (OpAllocString pos len) QaEmpty QaEmpty) nu = error "TODO"
quadToAsm (Quad4 x (OpCall fname) args QaEmpty) nu = error "TODO"
quadToAsm (Quad4 x (OpAssVar) y _) nu = error "TODO"

quadToAsm q@(Quad4 x op y z) nextUses = do
    rdesc <- lgets registerDesc
    adesc <- lgets addressDesc
    updateNextUses nextUses
    case Map.lookup x nextUses of
        Just xline -> do
            l <- giveReg y
            case y of
                QaVar vy -> case (Just $ Set.singleton vy) /= (Map.lookup l rdesc) of
                    True -> emit $ AMov (AAMem vy) (AAReg l)
                    False -> return ()
                QaConst cy -> return ()
            case z of
                _ -> do
                    zp <- whereVarPreferReg z
                    case (zp, op) of
                        (zarg, OpAdd) -> emit $ AAdd zarg (AAReg l)
                        (zarg, OpSub) -> emit $ ASub zarg (AAReg l)
                        (zarg, OpMul) -> emit $ AMul zarg (AAReg l)
                        (zarg, OpDiv) -> do
                            emit $ AMov (AAReg l) (AAReg Rax)
                            emit $ ACdq
                            emit $ ADiv zarg
                            emit $ AMov (AAReg Rax) (AAReg l)
                        (zarg, OpMod) -> do
                            emit $ AMov (AAReg l) (AAReg Rax)
                            emit $ ACdq
                            emit $ ADiv zarg
                            emit $ AMov (AAReg Rdx) (AAReg l)
                        (zarg, OpNeg) -> emit $ ANeg (AAReg l)
                        (zarg, OpAnd) -> emit $ AAnd zarg (AAReg l)
                        (zarg, OpOr) -> emit $ AOr zarg (AAReg l)
                        (zarg, OpCmpIntLt) -> emit $ AOr zarg (AAReg l)
                        (zarg, OpCmpIntLe) -> error ""
                        (zarg, OpCmpIntGt) -> error ""
                        (zarg, OpCmpIntGe) -> error ""
                        (zarg, OpCmpIntEq) -> error ""
                        (zarg, OpCmpIntNe) -> error ""

            update addressDesc (Map.insert x (Set.singleton l, Set.empty) adesc)
            update registerDesc (compose rdesc [removeFromAllSets x, Map.insert l (Set.singleton x)])
            case y of
                QaVar vy -> forgetIfUnused vy
                QaConst cy-> return ()
            case z of
                QaVar vz -> forgetIfUnused vz
                _ -> return ()
        Nothing -> return ()


quadsToAsm wrappedNextUses aliveBlockEnd = do
    mapM_ (uncurry quadToAsm) wrappedNextUses
    saveVarsAfterBlock aliveBlockEnd

--- translates block of quads to assembly, can modify memory
runQuadsToAsm :: [Quad] -> [Var] -> Map.Map Var MemoryLocation -> Int-> (Map.Map Var MemoryLocation, Int, [ASM])
runQuadsToAsm quads aliveBlockEnd varLocs fFree =
    let
        initSingleAd ad = (ad, (Set.empty, Set.singleton ad))
        initAddressDesc = Map.fromList $ map initSingleAd (Map.keys varLocs)
        initRegisterDesc = Map.empty
        initFirstFree = fFree
        initNextUseInfo = Map.empty
        initVarLocations = varLocs
        (wrapNextUses, aliveStart) = appendNextUses quads aliveBlockEnd
        pState = QuadProgState initAddressDesc initRegisterDesc initFirstFree initNextUseInfo initVarLocations
        evalResult = runEval pState (quadsToAsm wrapNextUses aliveBlockEnd) in
        case evalResult of
            Right ((a, s), w) -> (_varLocations s, _firstFree s, w)





-----------------------------
---- building CFG
--------------------------
type Graph = Map.Map Int [Int]

startsBlock :: Quad -> Bool
startsBlock q = case q of
    QuadNoAssign (OpLabel _) _ _ -> True
    Quad4 _ (OpCall _) _ _ -> True
    Quad4 _ (OpAllocString _ _) _ _ -> True
    _ -> False

endsBlock :: Quad -> Bool
endsBlock q = case q of
    QuadNoAssign (OpJmp _) _ _ -> True
    QuadNoAssign (OpGoToIfFalse _) _ _ -> True
    _ -> False


splitIntoBlocksHelper [] [] = []
splitIntoBlocksHelper cB [] = [cB]
splitIntoBlocksHelper currentBlock (quad:rest) = case startsBlock quad of
    True -> (currentBlock:(splitIntoBlocksHelper [quad] rest))
    False -> case endsBlock quad of
        True -> (quad:currentBlock):(splitIntoBlocksHelper [] rest)
        False -> splitIntoBlocksHelper (quad:currentBlock) rest

splitIntoBlocks quads = map reverse (splitIntoBlocksHelper [] quads)

lookupMany l m = result where
    lookupOne m x = case Map.lookup x m of
        Just x -> x
        Nothing -> []
    result = concatMap (lookupOne m) l

canGoTo :: (Int, [Quad]) -> (Int, [Quad]) -> Bool
canGoTo (i1, b1) (i2, b2) = case (last b1, head b2) of
    (QuadNoAssign (OpGoToIfFalse lab1) _ _, QuadNoAssign (OpLabel lab2) _ _) -> lab1 == lab2
    (QuadNoAssign (OpJmp lab1) _ _, QuadNoAssign (OpLabel lab2) _ _) -> lab1 == lab2
    _ -> (i1+1) == i2

buildCFG :: [[Quad]] -> Map.Map Int [Int]
buildCFG blocks = graph where
    numberedBlocksList = zip [1..] blocks
    numBlock = Map.fromList numberedBlocksList
    getSuccessors b1 = map fst $ filter (canGoTo b1) numberedBlocksList
    graph = Map.fromList $ zip [1..] (map getSuccessors numberedBlocksList)



--------------------------
------Calculating in-out for all blocks in CFG
-------------------------


cfgHelper1 :: Graph -> Graph -> Graph -> Graph -> Graph -> Int -> (Graph, Graph)
cfgHelper1 graph useM defM inM outM size = result where
    calcIn n = case (Map.lookup n useM, Map.lookup n outM, Map.lookup n defM) of
        (Just nuse, Just nout, Just ndef) -> (n, List.nub (nuse ++ (nout List.\\ ndef)))
        _ -> error "buildInout"
    calcOut n = case Map.lookup n graph of
       Just l -> (n, List.nub (lookupMany l inM))
       Nothing -> error "buildInout"
    r1 = map calcIn [1..size]
    r2 = map calcOut [1..size]
    result = (Map.fromList r1, Map.fromList r2)

cfgHelper2 graph useM defM inM outM size = case cfgHelper1 graph useM defM inM outM size of
        (a, b) -> case (a == inM) && (b == outM) of
            True -> (a, b)
            False -> cfgHelper2 graph useM defM a b size

calcInOut graph blocks = result where
    size = length blocks
    useM = Map.fromList $ zip [1..] (map usedInBlock blocks)
    defM = Map.fromList $ zip [1..] (map definedInBlock blocks)
    inM = Map.fromList $ zip [1..size] (repeat [])
    outM = Map.fromList $ zip [1..size] (repeat [])
    result = cfgHelper2 graph useM defM inM outM size


------------------------------
------------------------------
------------------------------













-----------------------
-----Test giveReg----
------------------
---------TESTING HERE
testGiveReg1 = let
        --- here starting conditions
        prepAdesc x = (Set.empty, Set.singleton x)
        ad = Map.fromList $ zip [1..5] (map prepAdesc [1..5])
        rd = Map.empty
        ff = 20
        nui = Map.empty
        vl = Map.fromList $ zip [1..5] [1..5]
        pState = QuadProgState ad rd ff nui vl
        evalResult = runEval pState (giveReg (QaVar 4)) in
        case evalResult of
            Right ((a, s), w) -> do
                runTest (ff == 21) "testGiveReg1"
                runTest (Map.null nui) "sdf"
            Left errMessage -> do hPutStrLn stderr "Testing failed badly"
                                  hPutStrLn stderr errMessage
                                  exitFailure


runTest :: Bool -> String -> IO ()
runTest ok msg = do
    case ok of
        True -> putStrLn "OK"
        False -> do hPutStrLn stderr "tests failed"
                    hPutStrLn stderr msg
                    exitFailure






v1 = QaVar 1
v2 = QaVar 2
v3 = QaVar 3
v4 = QaVar 4
v5 = QaVar 5
v6 = QaVar 6

ve = QaEmpty
v11 = QaList []
v12 = QaConst 5

qa1 = Quad4 5 OpAdd v2 v4
qa2 = QuadNoAssign (OpLabel ("L1")) ve ve
qa3 = Quad4 1 OpAdd v2 v3
qa4 = Quad4 2 OpAdd v3 v4
qa5 = QuadNoAssign (OpGoToIfFalse "L1") ve ve
qa6 = Quad4 4 OpAdd v5 v6
qa7 = Quad4 12 (OpCall "hehe") (QaList []) ve
qa8 = QuadNoAssign (OpJmp "L1") ve ve
qa9 = Quad4 6 OpAdd v5 v4

quadsTest = [qa1, qa2, qa3, qa4, qa5, qa6, qa7, qa8, qa9]
quadsBlocks = splitIntoBlocks quadsTest
cfgGraph = buildCFG quadsBlocks
ci = calcInOut cfgGraph quadsBlocks
--[(1,[2,4,3,6]),(2,[2,3,4,5,6]),(3,[5,6,2,3]),(4,[2,3,4,5,6]),(5,[5,4])],fromList [(1,[2,3,4,5,6]),(2,[2,3,4,5,6]),(3,[2,3,4,5,6]),(4,[2,3,4,5,6]),(5,[])]

testMap1 = Map.fromList [(1, "afh"), (2, "eee"), (5, "rrr")]
testLookupMany = (lookupMany [1, 5] testMap1) == "afhrrr"



quad1 = Quad4 1 OpAdd (QaVar 2) (QaVar 3)
quad2 = Quad4 4 OpAdd (QaVar 5) (QaVar 6)
quad3 = Quad4 7 OpAdd (QaVar 8) (QaVar 9)
quad4 = Quad4 10 OpAdd (QaVar 11) (QaVar 12)
quad5 = Quad4 13 OpAdd (QaVar 14) (QaVar 15)
ff = 50
quads = [quad1, quad2, quad3, quad4, quad5]
prepareQuads quads = reverse (zip [1..] quads)
--alQuad :: Map.Map Var LineNumber
--alQuad = Map.fromList [(1, 100), (5, 100)]


--ret = runQuadsToAsm quads 200 [1, 4, 7, 10, 13]
--------------



-----------
-----------
-------------


loadArgument i = case i of
    0 -> AMov (AAReg Rdi) (AAMem 0)
    1 -> AMov (AAReg Rsi) (AAMem 1)
    2 -> AMov (AAReg Rdx) (AAMem 2)
    3 -> AMov (AAReg Rcx) (AAMem 3)
    4 -> AMov (AAReg R8) (AAMem 4)
    5 -> AMov (AAReg R9) (AAMem 5)
    i -> APop (AAMem i)

loadArguments :: Int -> [ASM]
loadArguments args = map loadArgument [0..(args-1)]

--TODO fix assignment
--- MAIN function
--- returns assembly and the number of vars to allocate on stack
--- number of vars isn't known before translation, because asm can
--- in some cases save temporary values to the memory (and need some more than local variables)
functionToASM :: QuadFunction -> (String, [ASM])
functionToASM (QuadFunction (Ident name) quads argFreeMem args memory) = result where
    prolog = [APush (AAReg Rbp), AMov (AAReg Rsp) (AAReg Rbp)]
    loadArgs = loadArguments args
    epilog = [ALeave]

    varsInMemory = Map.keys memory
    aDescVals = zip (repeat Set.empty) (map Set.singleton varsInMemory)
    addressDesc = Map.fromList $ zip varsInMemory aDescVals

    blocks = splitIntoBlocks quads
    numberedBlocks = zip [1..] blocks
    graph = buildCFG blocks
    (inInfo, outInfo) = calcInOut graph blocks

    blocksToAsm ((i, q):t) mem freeLoc = case Map.lookup i outInfo of
        Just alive -> case runQuadsToAsm q alive mem freeLoc of
            (newMem, newFree, asm1) -> case blocksToAsm t newMem newFree of
                (asm2, fm2) -> (asm1 ++ asm2, fm2)
        Nothing -> error "fatal"
    blocksToAsm [] mem freeLoc = ([], freeLoc)

    shortenMem (vname, (position, ty)) = (vname, position)
    shortMem = Map.fromList $ map shortenMem (Map.toList memory)


    (asm, freeMem) = blocksToAsm (zip [1..] blocks) (shortMem) (argFreeMem)
    resultAsm = prolog ++ loadArgs ++ asm ++ epilog
    allocMemory = [ASub (AAConst (8 * freeMem)) (AAReg Rsp)]
    result = (name, allocMemory ++ resultAsm)
